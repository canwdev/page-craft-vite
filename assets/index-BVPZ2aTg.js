var t,e,r,i,a,n,s,o,c,l,h,f,p=Object.defineProperty,y=t=>{throw TypeError(t)},w=(t,e,r)=>((t,e,r)=>e in t?p(t,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[e]=r)(t,"symbol"!=typeof e?e+"":e,r),u=(t,e,r)=>e.has(t)||y("Cannot "+r),d=(t,e,r)=>(u(t,e,"read from private field"),r?r.call(t):e.get(t)),m=(t,e,r)=>e.has(t)?y("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(t):e.set(t,r),g=(t,e,r,i)=>(u(t,e,"write to private field"),i?i.call(t,r):e.set(t,r),r),v=(t,e,r)=>(u(t,e,"access private method"),r);const E=new TextDecoder,b=new TextEncoder;class A extends Error{constructor(t){super(`Method "${t}" does not exist on impl.`)}}class D extends Error{constructor(t){super(`Method "${t}" is not supported on this impl.`)}}class $ extends Error{constructor(){super("Implementation already set.")}}function k(t){if(!t||!(t instanceof URL)&&"string"!=typeof t)throw new TypeError("Path must be a non-empty string or URL.")}function x(t){if(!("string"==typeof t||t instanceof ArrayBuffer||ArrayBuffer.isView(t)))throw new TypeError("File contents must be a string, ArrayBuffer, or ArrayBuffer view.")}function T(t){if(t instanceof Uint8Array)return t;if("string"==typeof t)return b.encode(t);if(t instanceof ArrayBuffer)return new Uint8Array(t);if(ArrayBuffer.isView(t)){const e=t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength);return new Uint8Array(e)}throw new TypeError("Invalid contents type. Expected string or ArrayBuffer.")}class F{constructor(t,e){w(this,"type"),w(this,"data"),w(this,"timestamp",Date.now()),this.type=t,this.data=e}}class S{constructor({impl:a}){m(this,i),m(this,t),m(this,e),m(this,r,new Map),g(this,t,a),g(this,e,a)}logStart(t){if(!t||"string"!=typeof t)throw new TypeError("Log name must be a non-empty string.");if(d(this,r).has(t))throw new Error(`Log "${t}" already exists.`);d(this,r).set(t,[])}logEnd(t){if(d(this,r).has(t)){const e=d(this,r).get(t);return d(this,r).delete(t),e}throw new Error(`Log "${t}" does not exist.`)}isBaseImpl(){return d(this,e)===d(this,t)}setImpl(r){if(v(this,i,a).call(this,"implSet",r),d(this,e)!==d(this,t))throw new $;g(this,e,r)}resetImpl(){v(this,i,a).call(this,"implReset"),g(this,e,d(this,t))}async text(t){k(t);const e=await v(this,i,l).call(this,"bytes","text",t);return e?E.decode(e):void 0}async json(t){k(t);const e=await v(this,i,l).call(this,"bytes","json",t);return e?JSON.parse(E.decode(e)):void 0}async arrayBuffer(t){k(t);const e=await v(this,i,l).call(this,"bytes","arrayBuffer",t);return null==e?void 0:e.buffer}async bytes(t){return k(t),v(this,i,o).call(this,"bytes",t)}async write(t,e){k(t),x(e),v(this,i,a).call(this,"write",t,e);let r=T(e);return v(this,i,c).call(this,"write",t,r)}async append(t,e){k(t),x(e),v(this,i,a).call(this,"append",t,e);let r=T(e);return v(this,i,c).call(this,"append",t,r)}async isFile(t){return k(t),v(this,i,o).call(this,"isFile",t)}async isDirectory(t){return k(t),v(this,i,o).call(this,"isDirectory",t)}async createDirectory(t){return k(t),v(this,i,o).call(this,"createDirectory",t)}async delete(t){return k(t),v(this,i,o).call(this,"delete",t)}async deleteAll(t){return k(t),v(this,i,o).call(this,"deleteAll",t)}async*list(t){k(t),yield*await v(this,i,o).call(this,"list",t)}async*walk(t,{directoryFilter:e=()=>!0,entryFilter:r=()=>!0}={}){k(t),v(this,i,a).call(this,"walk",t,{directoryFilter:e,entryFilter:r});const n=async function*(t,{directoryFilter:e,entryFilter:r,parentPath:a="",depth:s=1}){let o;try{o=await v(this,i,c).call(this,"list",t)}catch(l){if("ENOENT"===l.code)return;throw l}for await(const i of o){const o={path:i.name,depth:s,...i};a&&(o.path=`${a}/${o.path}`);let c=r(o);if(c.then&&(c=await c),c&&(yield o),i.isDirectory){let a=e(o);if(a.then&&(a=await a),!a)continue;const c=t instanceof URL?new URL(i.name,t.href.endsWith("/")?t.href:`${t.href}/`):`${t.endsWith("/")?t:`${t}/`}${i.name}`;yield*n(c,{directoryFilter:e,entryFilter:r,parentPath:o.path,depth:s+1})}}}.bind(this);yield*n(t,{directoryFilter:e,entryFilter:r})}async size(t){return k(t),v(this,i,o).call(this,"size",t)}async lastModified(t){return k(t),v(this,i,o).call(this,"lastModified",t)}async copy(t,e){return k(t),k(e),v(this,i,o).call(this,"copy",t,e)}async copyAll(t,e){return k(t),k(e),v(this,i,o).call(this,"copyAll",t,e)}async move(t,e){return k(t),k(e),v(this,i,o).call(this,"move",t,e)}async moveAll(t,e){return k(t),k(e),v(this,i,o).call(this,"moveAll",t,e)}}function M(t){let e=0,r=t.length;return/[a-z]:\//i.test(t)&&(e=3),t.startsWith("./")&&(e=2),t.startsWith("/")&&(e=1),t.endsWith("/")&&(r=t.length-1),t.slice(e,r).replace(/\\/g,"/")}function P(t){if("string"!=typeof t)throw new TypeError("name must be a string");if(!t)throw new TypeError("name cannot be empty");if("."===t)throw new TypeError('name cannot be "."');if(".."===t)throw new TypeError('name cannot be ".."');if(t.includes("/")||t.includes("\\"))throw new TypeError(`name cannot contain a slash or backslash: "${t}"`)}t=new WeakMap,e=new WeakMap,r=new WeakMap,i=new WeakSet,a=function(t,...e){for(const i of d(this,r).values())i.push(new F("call",{methodName:t,args:e}))},n=function(t){if("function"!=typeof d(this,e)[t])throw new A(t)},s=function(t,r){if("function"!=typeof d(this,e)[t])throw new D(r)},o=function(t,...r){return v(this,i,a).call(this,t,...r),v(this,i,n).call(this,t),d(this,e)[t](...r)},c=function(t,...r){return v(this,i,n).call(this,t),d(this,e)[t](...r)},l=function(t,r,...n){return v(this,i,a).call(this,r,...n),v(this,i,s).call(this,t,r),d(this,e)[t](...n)};const R=class t{constructor(t=[]){if(m(this,h),"function"!=typeof t[Symbol.iterator])throw new TypeError("steps must be iterable");g(this,h,[...t]),d(this,h).forEach(P)}push(...t){t.forEach(P),d(this,h).push(...t)}pop(){return d(this,h).pop()}steps(){return d(this,h).values()}[Symbol.iterator](){return this.steps()}get name(){return d(this,h)[d(this,h).length-1]}set name(t){P(t),d(this,h)[d(this,h).length-1]=t}get size(){return d(this,h).length}toString(){return d(this,h).join("/")}static from(e){if("string"==typeof e){if(!e)throw new TypeError("argument cannot be empty");return t.fromString(e)}if(e instanceof URL)return t.fromURL(e);if(e instanceof t||Array.isArray(e))return new t(e);throw new TypeError("argument must be a string, URL, Path, or Array")}static fromString(e){return new t(M(e).split("/"))}static fromURL(e){if(!(e instanceof URL))throw new TypeError("url must be a URL instance");if(!e.pathname||"/"===e.pathname)throw new TypeError("url.pathname cannot be empty");if("file:"!==e.protocol)throw new TypeError('url.protocol must be "file:"');return new t(M(e.pathname.slice(1)).split("/"))}};h=new WeakMap;let L=R;class U extends Error{constructor(t){super(`ENOENT: No such file or directory, ${t}`),w(this,"name","NotFoundError"),w(this,"code","ENOENT")}}class z extends Error{constructor(t){super(`EISDIR: Illegal operation on a directory, ${t}`),w(this,"name","DirectoryError"),w(this,"code","EISDIR")}}class W extends Error{constructor(t){super(`ENOTEMPTY: Directory not empty, ${t}`),w(this,"name","NotEmptyError"),w(this,"code","ENOTEMPTY")}}async function j(t,e,{returnParent:r=!1,create:i=!1,kind:a}={}){if("."===e)return t;const n=[...L.from(e)];r&&n.pop();let s=t,o=n.shift();for(;s&&o;){if(n.length>0)try{s=await s.getDirectoryHandle(o,{create:i})}catch{return}else{if(!a)try{return await s.getDirectoryHandle(o,{create:i})}catch{try{return await s.getFileHandle(o,{create:i})}catch{return}}if("directory"===a)try{return await s.getDirectoryHandle(o,{create:i})}catch{return}if("file"===a)try{return await s.getFileHandle(o,{create:i})}catch{return}}o=n.shift()}}class N{constructor({root:t}){if(m(this,f),!t)throw new TypeError("options.root is required");g(this,f,t)}async bytes(t){const e=await async function(t,e){const r=await j(t,e);if(!r||"file"!==r.kind)return;const i=r;return(await i.getFile()).arrayBuffer()}(d(this,f),t);return e?new Uint8Array(e):void 0}async write(t,e){let r=await j(d(this,f),t);if(!r){const e=L.from(t).name,i=await j(d(this,f),t,{create:!0,kind:"directory",returnParent:!0})??d(this,f);r=await i.getFileHandle(e,{create:!0})}const i=await r.createWritable();await i.write(e),await i.close()}async append(t,e){const r=await j(d(this,f),t);if(!r)return this.write(t,e);if("file"!==r.kind)throw new z(`append '${t}'`);const i=await(await r.getFile()).arrayBuffer(),a=new Uint8Array([...new Uint8Array(i),...e]);return this.write(t,a)}async isFile(t){const e=await j(d(this,f),t);return!(!e||"file"!==e.kind)}async isDirectory(t){const e=await j(d(this,f),t);return!(!e||"directory"!==e.kind)}async createDirectory(t){let e=d(this,f);const r=L.from(t);for(const i of r)e=await e.getDirectoryHandle(i,{create:!0})}async delete(t){const e=await j(d(this,f),t),r=await j(d(this,f),t,{returnParent:!0})??d(this,f);if(!e)return!1;if("directory"===e.kind){const r=e.values();if(!(await r.next()).done)throw new W(`delete '${t}'`)}return r.removeEntry(e.name),!0}async deleteAll(t){const e=await j(d(this,f),t);if(!e)return!1;if(e.remove)return await e.remove({recursive:!0}),!0;const r=await j(d(this,f),t,{returnParent:!0})??d(this,f);if(!e)throw new U(`deleteAll '${t}'`);return r.removeEntry(e.name,{recursive:!0}),!0}async*list(t){const e=await j(d(this,f),t);if(e)for await(const r of e.values()){const t="directory"===r.kind,e="file"===r.kind;yield{name:r.name,isDirectory:t,isFile:e,isSymlink:!1}}}async size(t){const e=await j(d(this,f),t);if(!e||"file"!==e.kind)return;const r=e;return(await r.getFile()).size}async lastModified(t){const e=await j(d(this,f),t);if(!e)return;if("file"===e.kind){const t=e,r=await t.getFile();return new Date(r.lastModified)}let r=new Date(0);for await(const i of this.list(t)){const e=L.from(t);e.push(i.name);const a=await this.lastModified(e.toString());a&&a>r&&(r=a)}return 0===r.getTime()?new Date:r}async copy(t,e){const r=await j(d(this,f),t);if(!r)throw new U(`copy '${t}' -> '${e}'`);if("file"!==r.kind)throw new z(`copy '${t}' -> '${e}'`);if(await this.isDirectory(e))throw new z(`copy '${t}' -> '${e}'`);const i=await j(d(this,f),e,{create:!0,kind:"file"}),a=await r.getFile(),n=await i.createWritable();await n.write(a),await n.close()}async copyAll(t,e){if(await this.isFile(t))return this.copy(t,e);if(!(await this.isDirectory(t)))throw new U(`copyAll '${t}' -> '${e}'`);const r=L.from(t),i=L.from(e);await this.createDirectory(e);for await(const a of this.list(t))i.push(a.name),r.push(a.name),a.isDirectory?await this.copyAll(r.toString(),i.toString()):await this.copy(r.toString(),i.toString()),i.pop(),r.pop()}async move(t,e){const r=await j(d(this,f),t);if(!r)throw new U(`move '${t}' -> '${e}'`);if("file"!==r.kind)throw new z(`move '${t}' -> '${e}'`);const i=r,a=L.from(e),n=a.pop(),s=await j(d(this,f),a.toString(),{create:!0,kind:"directory"});return i.move(s,n).catch((async r=>{if("NotAllowedError"===r.name)return await this.copy(t,e),void(await this.delete(t));throw r}))}async moveAll(t,e){const r=await j(d(this,f),t);if(!r)throw new U(`moveAll '${t}' -> '${e}'`);if("file"===r.kind)return this.move(t,e);const i=r,a=L.from(e);if(i.move){const t=a.pop(),e=await j(d(this,f),a.toString(),{create:!0,kind:"directory"});return i.move(e,t)}const n=L.from(t);await this.createDirectory(e);for await(const s of this.list(t))a.push(s.name),n.push(s.name),s.isDirectory?await this.moveAll(n.toString(),a.toString()):await this.move(n.toString(),a.toString()),a.pop(),n.pop();await this.delete(t)}}f=new WeakMap;class I extends S{constructor({root:t}){super({impl:new N({root:t})})}}new I({root:await navigator.storage.getDirectory()});const B=class t{static normalize(t){return t.replace(/\\/gi,"/").replace(/\/+/gi,"/")}static join(...e){for(var r=[],i=0;i<e.length;i++){var a=e[i];if("string"!=typeof a)throw new TypeError("Invalid argument type to path.join: "+typeof a);""!==a&&r.push(a)}return t.normalize(r.join(t.sep))}static resolve(...e){for(var r=[],i=0;i<e.length;i++){var a=e[i];if("string"!=typeof a)throw new TypeError("Invalid argument type to path.join: "+typeof a);""!==a&&(a.charAt(0)===t.sep&&(r=[]),r.push(a))}var n=t.normalize(r.join(t.sep));if(n.length>1&&n.charAt(n.length-1)===t.sep)return n.substr(0,n.length-1);if(n.charAt(0)!==t.sep){"."!==n.charAt(0)||1!==n.length&&n.charAt(1)!==t.sep||(n=1===n.length?"":n.substr(2));var s=process.cwd();n=""!==n?this.normalize(s+("/"!==s?t.sep:"")+n):s}return n}static relative(e,r){var i;e=t.resolve(e),r=t.resolve(r);var a=e.split(t.sep),n=r.split(t.sep);n.shift(),a.shift();var s=0,o=[];for(i=0;i<a.length;i++){if(a[i]!==n[i]){s=a.length-i;break}}o=n.slice(i),1===a.length&&""===a[0]&&(s=0),s>a.length&&(s=a.length);var c="";for(i=0;i<s;i++)c+="../";return(c+=o.join(t.sep)).length>1&&c.charAt(c.length-1)===t.sep&&(c=c.substr(0,c.length-1)),c}static dirname(e){var r=(e=t._removeDuplicateSeps(e)).charAt(0)===t.sep,i=e.split(t.sep);return""===i.pop()&&i.length>0&&i.pop(),i.length>1?i.join(t.sep):r?t.sep:"."}static basename(e,r=""){if(""===e)return e;var i=(e=t.normalize(e)).split(t.sep),a=i[i.length-1];if(""===a&&i.length>1)return i[i.length-2];if(r.length>0&&a.substr(a.length-r.length)===r)return a.substr(0,a.length-r.length);return a}static extname(e){var r=(e=t.normalize(e)).split(t.sep);if(""===(e=r.pop())&&r.length>0&&(e=r.pop()),".."===e)return"";var i=e.lastIndexOf(".");return-1===i||0===i?"":e.substr(i)}static isAbsolute(e){return e.length>0&&e.charAt(0)===t.sep}static _makeLong(t){return t}static _removeDuplicateSeps(t){return t=t.replace(this._replaceRegex,this.sep)}};w(B,"sep","/"),w(B,"_replaceRegex",new RegExp("//+","g")),w(B,"delimiter",":");let O=B,H=await navigator.storage.getDirectory(),_=new I({root:H});const C=async t=>{H=t||await navigator.storage.getDirectory(),_=new I({root:H})};console.log("[hfs]",_);const V=t=>"/"!==t&&t?t:".",Y={getRoot:()=>H,async getList({path:t,isStat:e=!1}){var r;const i=[];t=V(t);for await(const a of _.list(t)){const n=O.extname(a.name||"")||"",s=O.normalize(t+"/"+a.name);i.push({name:a.name,ext:n,isDirectory:a.isDirectory,hidden:a.name.startsWith("."),lastModified:e&&(null==(r=await _.lastModified(s))?void 0:r.getTime())||0,birthtime:0,size:e?await _.size(s):void 0})}return i},async getFile(t){const{path:e,mode:r="text"}=t,i=V(e);return"text"===r?await _.text(i):"json"===r?await _.json(i):await _.bytes(i)},async createDir(t){let{path:e,ignoreExisted:r=!1}=t;return e=V(e),r&&await _.isDirectory(e)||await _.createDirectory(e),{path:e}},async createFile(t,e={}){let{path:r,file:i,isOverride:a=!1}=t;if(r=V(r),!a&&await _.isFile(r))throw new Error(`file ${r} already exist!`);await _.write(r,i)},async writeFile(t,e={}){let{path:r,file:i}=t;r=V(r),await _.write(r,i)},async renameEntry(t){const{fromPath:e,toPath:r}=t,i=V(e),a=V(r);await _.isDirectory(i)?await _.moveAll(i,a):await _.move(i,a)},async copyPaste(t){const{fromPaths:e,toPath:r,isMove:i,toPathAbs:a}=t;for(let n=0;n<e.length;n++){const t=e[n],s=V(t);let o;if(a)o=V(a);else{const t=O.basename(s);o=V(O.join(r,t))}i?await _.isDirectory(s)?await _.moveAll(s,o):await _.move(s,o):await _.isDirectory(s)?await _.copyAll(s,o):await _.copy(s,o)}},async deleteEntry(t){const{path:e}=t,r=async t=>{const e=V(t);await _.isDirectory(e)?await _.deleteAll(e):await _.delete(e)};if(Array.isArray(e))for(let i=0;i<e.length;i++){const t=e[i];await r(t)}else await r(e)}},q=t=>t.replace(/\\/gi,"/").replace(/\/+/gi,"/"),J=(t,e)=>{const r=t.indexOf(e);return-1!==r?t.splice(r,1):t.push(e),t},G=t=>(t=t.replace(/\/$/gi,"")).split("/").pop()||"/";export{Y as f,G as g,q as n,C as s,J as t};
