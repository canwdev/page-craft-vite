var t,e,r,i,a,s,n,o,c,l,h,f,p=Object.defineProperty,w=t=>{throw TypeError(t)},y=(t,e,r)=>((t,e,r)=>e in t?p(t,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[e]=r)(t,"symbol"!=typeof e?e+"":e,r),u=(t,e,r)=>e.has(t)||w("Cannot "+r),m=(t,e,r)=>(u(t,e,"read from private field"),r?r.call(t):e.get(t)),d=(t,e,r)=>e.has(t)?w("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(t):e.set(t,r),g=(t,e,r,i)=>(u(t,e,"write to private field"),i?i.call(t,r):e.set(t,r),r),v=(t,e,r)=>(u(t,e,"access private method"),r);const E=t=>t.replace(/\\/gi,"/").replace(/\/+/gi,"/"),b=(t,e)=>{const r=t.indexOf(e);return-1!==r?t.splice(r,1):t.push(e),t},A=t=>(t=t.replace(/\/$/gi,"")).split("/").pop()||"/",D=new TextDecoder,x=new TextEncoder;class T extends Error{constructor(t){super(`Method "${t}" does not exist on impl.`)}}class k extends Error{constructor(t){super(`Method "${t}" is not supported on this impl.`)}}class S extends Error{constructor(){super("Implementation already set.")}}function $(t){if(!t||!(t instanceof URL)&&"string"!=typeof t)throw new TypeError("Path must be a non-empty string or URL.")}function F(t){if(!("string"==typeof t||t instanceof ArrayBuffer||ArrayBuffer.isView(t)))throw new TypeError("File contents must be a string, ArrayBuffer, or ArrayBuffer view.")}function M(t){if(t instanceof Uint8Array)return t;if("string"==typeof t)return x.encode(t);if(t instanceof ArrayBuffer)return new Uint8Array(t);if(ArrayBuffer.isView(t)){const e=t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength);return new Uint8Array(e)}throw new TypeError("Invalid contents type. Expected string or ArrayBuffer.")}class z{constructor(t,e){y(this,"type"),y(this,"data"),y(this,"timestamp",Date.now()),this.type=t,this.data=e}}class P{constructor({impl:a}){d(this,i),d(this,t),d(this,e),d(this,r,new Map),g(this,t,a),g(this,e,a)}logStart(t){if(!t||"string"!=typeof t)throw new TypeError("Log name must be a non-empty string.");if(m(this,r).has(t))throw new Error(`Log "${t}" already exists.`);m(this,r).set(t,[])}logEnd(t){if(m(this,r).has(t)){const e=m(this,r).get(t);return m(this,r).delete(t),e}throw new Error(`Log "${t}" does not exist.`)}isBaseImpl(){return m(this,e)===m(this,t)}setImpl(r){if(v(this,i,a).call(this,"implSet",r),m(this,e)!==m(this,t))throw new S;g(this,e,r)}resetImpl(){v(this,i,a).call(this,"implReset"),g(this,e,m(this,t))}async text(t){$(t);const e=await v(this,i,l).call(this,"bytes","text",t);return e?D.decode(e):void 0}async json(t){$(t);const e=await v(this,i,l).call(this,"bytes","json",t);return e?JSON.parse(D.decode(e)):void 0}async arrayBuffer(t){$(t);const e=await v(this,i,l).call(this,"bytes","arrayBuffer",t);return null==e?void 0:e.buffer}async bytes(t){return $(t),v(this,i,o).call(this,"bytes",t)}async write(t,e){$(t),F(e),v(this,i,a).call(this,"write",t,e);let r=M(e);return v(this,i,c).call(this,"write",t,r)}async append(t,e){$(t),F(e),v(this,i,a).call(this,"append",t,e);let r=M(e);return v(this,i,c).call(this,"append",t,r)}async isFile(t){return $(t),v(this,i,o).call(this,"isFile",t)}async isDirectory(t){return $(t),v(this,i,o).call(this,"isDirectory",t)}async createDirectory(t){return $(t),v(this,i,o).call(this,"createDirectory",t)}async delete(t){return $(t),v(this,i,o).call(this,"delete",t)}async deleteAll(t){return $(t),v(this,i,o).call(this,"deleteAll",t)}async*list(t){$(t),yield*await v(this,i,o).call(this,"list",t)}async size(t){return $(t),v(this,i,o).call(this,"size",t)}async lastModified(t){return $(t),v(this,i,o).call(this,"lastModified",t)}async copy(t,e){return $(t),$(e),v(this,i,o).call(this,"copy",t,e)}async copyAll(t,e){return $(t),$(e),v(this,i,o).call(this,"copyAll",t,e)}async move(t,e){return $(t),$(e),v(this,i,o).call(this,"move",t,e)}async moveAll(t,e){return $(t),$(e),v(this,i,o).call(this,"moveAll",t,e)}}function R(t){let e=0,r=t.length;return/[a-z]:\//i.test(t)&&(e=3),t.startsWith("./")&&(e=2),t.startsWith("/")&&(e=1),t.endsWith("/")&&(r=t.length-1),t.slice(e,r).replace(/\\/g,"/")}function j(t){if("string"!=typeof t)throw new TypeError("name must be a string");if(!t)throw new TypeError("name cannot be empty");if("."===t)throw new TypeError('name cannot be "."');if(".."===t)throw new TypeError('name cannot be ".."');if(t.includes("/")||t.includes("\\"))throw new TypeError(`name cannot contain a slash or backslash: "${t}"`)}t=new WeakMap,e=new WeakMap,r=new WeakMap,i=new WeakSet,a=function(t,...e){for(const i of m(this,r).values())i.push(new z("call",{methodName:t,args:e}))},s=function(t){if("function"!=typeof m(this,e)[t])throw new T(t)},n=function(t,r){if("function"!=typeof m(this,e)[t])throw new k(r)},o=function(t,...r){return v(this,i,a).call(this,t,...r),v(this,i,s).call(this,t),m(this,e)[t](...r)},c=function(t,...r){return v(this,i,s).call(this,t),m(this,e)[t](...r)},l=function(t,r,...s){return v(this,i,a).call(this,r,...s),v(this,i,n).call(this,t,r),m(this,e)[t](...s)};const L=class t{constructor(t=[]){if(d(this,h),"function"!=typeof t[Symbol.iterator])throw new TypeError("steps must be iterable");g(this,h,[...t]),m(this,h).forEach(j)}push(...t){t.forEach(j),m(this,h).push(...t)}pop(){return m(this,h).pop()}steps(){return m(this,h).values()}[Symbol.iterator](){return this.steps()}get name(){return m(this,h)[m(this,h).length-1]}set name(t){j(t),m(this,h)[m(this,h).length-1]=t}get size(){return m(this,h).length}toString(){return m(this,h).join("/")}static from(e){if("string"==typeof e){if(!e)throw new TypeError("argument cannot be empty");return t.fromString(e)}if(e instanceof URL)return t.fromURL(e);if(e instanceof t||Array.isArray(e))return new t(e);throw new TypeError("argument must be a string, URL, Path, or Array")}static fromString(e){return new t(R(e).split("/"))}static fromURL(e){if(!(e instanceof URL))throw new TypeError("url must be a URL instance");if(!e.pathname||"/"===e.pathname)throw new TypeError("url.pathname cannot be empty");if("file:"!==e.protocol)throw new TypeError('url.protocol must be "file:"');return new t(R(e.pathname.slice(1)).split("/"))}};h=new WeakMap;let U=L;class I extends Error{constructor(t){super(`ENOENT: No such file or directory, ${t}`),y(this,"name","NotFoundError"),y(this,"code","ENOENT")}}class W extends Error{constructor(t){super(`EISDIR: Illegal operation on a directory, ${t}`),y(this,"name","DirectoryError"),y(this,"code","EISDIR")}}class B extends Error{constructor(t){super(`ENOTEMPTY: Directory not empty, ${t}`),y(this,"name","NotEmptyError"),y(this,"code","ENOTEMPTY")}}async function N(t,e,{returnParent:r=!1,create:i=!1,kind:a}={}){if("."===e)return t;const s=[...U.from(e)];r&&s.pop();let n=t,o=s.shift();for(;n&&o;){if(s.length>0)try{n=await n.getDirectoryHandle(o,{create:i})}catch{return}else{if(!a)try{return await n.getDirectoryHandle(o,{create:i})}catch{try{return await n.getFileHandle(o,{create:i})}catch{return}}if("directory"===a)try{return await n.getDirectoryHandle(o,{create:i})}catch{return}if("file"===a)try{return await n.getFileHandle(o,{create:i})}catch{return}}o=s.shift()}}class O{constructor({root:t}){if(d(this,f),!t)throw new TypeError("options.root is required");g(this,f,t)}async bytes(t){const e=await async function(t,e,r){const i=await N(t,e);if(!i||"file"!==i.kind)return;const a=i;return(await a.getFile()).arrayBuffer()}(m(this,f),t);return e?new Uint8Array(e):void 0}async write(t,e){let r=await N(m(this,f),t);if(!r){const e=U.from(t).name,i=await N(m(this,f),t,{create:!0,kind:"directory",returnParent:!0})??m(this,f);r=await i.getFileHandle(e,{create:!0})}const i=await r.createWritable();await i.write(e),await i.close()}async append(t,e){const r=await N(m(this,f),t);if(!r)return this.write(t,e);if("file"!==r.kind)throw new W(`append '${t}'`);const i=await(await r.getFile()).arrayBuffer(),a=new Uint8Array([...new Uint8Array(i),...e]);return this.write(t,a)}async isFile(t){const e=await N(m(this,f),t);return!(!e||"file"!==e.kind)}async isDirectory(t){const e=await N(m(this,f),t);return!(!e||"directory"!==e.kind)}async createDirectory(t){let e=m(this,f);const r=U.from(t);for(const i of r)e=await e.getDirectoryHandle(i,{create:!0})}async delete(t){const e=await N(m(this,f),t),r=await N(m(this,f),t,{returnParent:!0})??m(this,f);if(!e)return!1;if("directory"===e.kind){const r=e.values();if(!(await r.next()).done)throw new B(`delete '${t}'`)}return r.removeEntry(e.name),!0}async deleteAll(t){const e=await N(m(this,f),t);if(!e)return!1;if(e.remove)return await e.remove({recursive:!0}),!0;const r=await N(m(this,f),t,{returnParent:!0})??m(this,f);if(!e)throw new I(`deleteAll '${t}'`);return r.removeEntry(e.name,{recursive:!0}),!0}async*list(t){const e=await N(m(this,f),t);if(e)for await(const r of e.values()){const t="directory"===r.kind,e="file"===r.kind;yield{name:r.name,isDirectory:t,isFile:e,isSymlink:!1}}}async size(t){const e=await N(m(this,f),t);if(!e||"file"!==e.kind)return;const r=e;return(await r.getFile()).size}async lastModified(t){const e=await N(m(this,f),t);if(!e)return;if("file"===e.kind){const t=e,r=await t.getFile();return new Date(r.lastModified)}let r=new Date(0);for await(const i of this.list(t)){const e=U.from(t);e.push(i.name);const a=await this.lastModified(e.toString());a&&a>r&&(r=a)}return 0===r.getTime()?new Date:r}async copy(t,e){const r=await N(m(this,f),t);if(!r)throw new I(`copy '${t}' -> '${e}'`);if("file"!==r.kind)throw new W(`copy '${t}' -> '${e}'`);if(await this.isDirectory(e))throw new W(`copy '${t}' -> '${e}'`);const i=await N(m(this,f),e,{create:!0,kind:"file"}),a=await r.getFile(),s=await i.createWritable();await s.write(a),await s.close()}async copyAll(t,e){if(await this.isFile(t))return this.copy(t,e);if(!(await this.isDirectory(t)))throw new I(`copyAll '${t}' -> '${e}'`);const r=U.from(t),i=U.from(e);await this.createDirectory(e);for await(const a of this.list(t))i.push(a.name),r.push(a.name),a.isDirectory?await this.copyAll(r.toString(),i.toString()):await this.copy(r.toString(),i.toString()),i.pop(),r.pop()}async move(t,e){const r=await N(m(this,f),t);if(!r)throw new I(`move '${t}' -> '${e}'`);if("file"!==r.kind)throw new W(`move '${t}' -> '${e}'`);const i=r,a=U.from(e),s=a.pop(),n=await N(m(this,f),a.toString(),{create:!0,kind:"directory"});return i.move(n,s).catch((async r=>{if("NotAllowedError"===r.name)return await this.copy(t,e),void(await this.delete(t));throw r}))}async moveAll(t,e){const r=await N(m(this,f),t);if(!r)throw new I(`moveAll '${t}' -> '${e}'`);if("file"===r.kind)return this.move(t,e);const i=r,a=U.from(e);if(i.move){const t=a.pop(),e=await N(m(this,f),a.toString(),{create:!0,kind:"directory"});return i.move(e,t)}const s=U.from(t);await this.createDirectory(e);for await(const n of this.list(t))a.push(n.name),s.push(n.name),n.isDirectory?await this.moveAll(s.toString(),a.toString()):await this.move(s.toString(),a.toString()),a.pop(),s.pop();await this.delete(t)}}f=new WeakMap;class H extends P{constructor({root:t}){super({impl:new O({root:t})})}}new H({root:await navigator.storage.getDirectory()});const _=class t{static normalize(t){return t.replace(/\\/gi,"/").replace(/\/+/gi,"/")}static join(...e){for(var r=[],i=0;i<e.length;i++){var a=e[i];if("string"!=typeof a)throw new TypeError("Invalid argument type to path.join: "+typeof a);""!==a&&r.push(a)}return t.normalize(r.join(t.sep))}static resolve(...e){for(var r=[],i=0;i<e.length;i++){var a=e[i];if("string"!=typeof a)throw new TypeError("Invalid argument type to path.join: "+typeof a);""!==a&&(a.charAt(0)===t.sep&&(r=[]),r.push(a))}var s=t.normalize(r.join(t.sep));if(s.length>1&&s.charAt(s.length-1)===t.sep)return s.substr(0,s.length-1);if(s.charAt(0)!==t.sep){"."!==s.charAt(0)||1!==s.length&&s.charAt(1)!==t.sep||(s=1===s.length?"":s.substr(2));var n=process.cwd();s=""!==s?this.normalize(n+("/"!==n?t.sep:"")+s):n}return s}static relative(e,r){var i;e=t.resolve(e),r=t.resolve(r);var a=e.split(t.sep),s=r.split(t.sep);s.shift(),a.shift();var n=0,o=[];for(i=0;i<a.length;i++){if(a[i]!==s[i]){n=a.length-i;break}}o=s.slice(i),1===a.length&&""===a[0]&&(n=0),n>a.length&&(n=a.length);var c="";for(i=0;i<n;i++)c+="../";return(c+=o.join(t.sep)).length>1&&c.charAt(c.length-1)===t.sep&&(c=c.substr(0,c.length-1)),c}static dirname(e){var r=(e=t._removeDuplicateSeps(e)).charAt(0)===t.sep,i=e.split(t.sep);return""===i.pop()&&i.length>0&&i.pop(),i.length>1?i.join(t.sep):r?t.sep:"."}static basename(e,r=""){if(""===e)return e;var i=(e=t.normalize(e)).split(t.sep),a=i[i.length-1];if(""===a&&i.length>1)return i[i.length-2];if(r.length>0&&a.substr(a.length-r.length)===r)return a.substr(0,a.length-r.length);return a}static extname(e){var r=(e=t.normalize(e)).split(t.sep);if(""===(e=r.pop())&&r.length>0&&(e=r.pop()),".."===e)return"";var i=e.lastIndexOf(".");return-1===i||0===i?"":e.substr(i)}static isAbsolute(e){return e.length>0&&e.charAt(0)===t.sep}static _makeLong(t){return t}static _removeDuplicateSeps(t){return t=t.replace(this._replaceRegex,this.sep)}};y(_,"sep","/"),y(_,"_replaceRegex",new RegExp("//+","g")),y(_,"delimiter",":");let C=_,V=await navigator.storage.getDirectory(),Y=new H({root:V});const q=async t=>{V=t||await navigator.storage.getDirectory(),Y=new H({root:V})};console.log("[hfs]",Y);const J=t=>"/"!==t&&t?t:".",G={getRoot:()=>V,async getList({path:t,isStat:e=!1}){var r;const i=[];t=J(t);for await(const a of Y.list(t)){const s=C.extname(a.name||"")||"",n=C.normalize(t+"/"+a.name);i.push({name:a.name,ext:s,isDirectory:a.isDirectory,hidden:a.name.startsWith("."),lastModified:e&&(null==(r=await Y.lastModified(n))?void 0:r.getTime())||0,birthtime:0,size:e?await Y.size(n):void 0})}return i},async getFile(t){const{path:e,mode:r="text"}=t,i=J(e);return"text"===r?await Y.text(i):"json"===r?await Y.json(i):await Y.bytes(i)},async createDir(t){let{path:e,ignoreExisted:r=!1}=t;return e=J(e),r&&await Y.isDirectory(e)||await Y.createDirectory(e),{path:e}},async createFile(t,e={}){let{path:r,file:i,isOverride:a=!1}=t;if(r=J(r),!a&&await Y.isFile(r))throw new Error(`file ${r} already exist!`);await Y.write(r,i)},async writeFile(t,e={}){let{path:r,file:i}=t;r=J(r),await Y.write(r,i)},async renameEntry(t){const{fromPath:e,toPath:r}=t,i=J(e),a=J(r);await Y.isDirectory(i)?await Y.moveAll(i,a):await Y.move(i,a)},async copyPaste(t){const{fromPaths:e,toPath:r,isMove:i,toPathAbs:a}=t;for(let s=0;s<e.length;s++){const t=e[s],n=J(t);let o;if(a)o=J(a);else{const t=C.basename(n);o=J(C.join(r,t))}i?await Y.isDirectory(n)?await Y.moveAll(n,o):await Y.move(n,o):await Y.isDirectory(n)?await Y.copyAll(n,o):await Y.copy(n,o)}},async deleteEntry(t){const{path:e}=t,r=async t=>{const e=J(t);await Y.isDirectory(e)?await Y.deleteAll(e):await Y.delete(e)};if(Array.isArray(e))for(let i=0;i<e.length;i++){const t=e[i];await r(t)}else await r(e)}};export{G as f,A as g,E as n,q as s,b as t};
